#!/usr/bin/env perl
# try -h
# Make a "patch" in a project, extract it to a lib, with skeleton .cpp


use strict; use warnings; no warnings 'uninitialized'; use 5.010; no if ($^V ge v5.18.0), warnings => 'experimental::smartmatch';
use File::Glob ':bsd_glob';
use File::Basename qw(basename dirname);
use File::Spec;
use Cwd;
use IO::File;
use JSON;
use awgrover::Getopt;
use Carp;

$SIG{__DIE__} = sub { Carp::confess @_ };

our $switches;

sub debug(&) {
    if ($ENV{'DEBUG'}) {
      my @lines = &{$_[0]};
      my $at = (caller(0))[2];
      warn "[DEBUG $at] ". $lines[0]."\n";
      for ( @lines[1..(@lines-1)] ) {
        warn "[DEBUG ".(' ' x length("".$at))."] ". $_ . "\n";
        }
      }
    }

sub FIXME {
  my $at = (caller(0))[2];
  warn "[--FIXME-- $at] ", @_, "\n";
  }

sub warning {
    warn "WARNING ",@_,"\n";
    }

package XODPatch;
  use Class::MethodMaker 
    [ 
    new => [ qw( -init new )],
    scalar => [ 
      'parent', # a XODProject/lib
      'name', # patchname
      '_xodp', # cached .xodp
      ],
    ];

  use Carp;
  use JSON;

  sub debug(&){ goto &main::debug; }
  sub warning { goto &main::warning; }
  sub FIXME{ goto &main::FIXME; }

  sub init {
    my $self=shift;
    my ($parent, $name) = @_;
    $self->parent($parent);
    $self->name($name);
    debug { "XODPatch from ".$self->parent->short_name.": ".$self->name };
    }

  sub type { 'patch' }

  sub path { 
    my $self = shift;
    $self->parent->path . "/" . $self->name;
    }

  sub exists {
    # does the patch actually exist
    my $self=shift;
    -e $self->path . "/patch.xodp";
    }

  sub short_name {
    my $self=shift;
    $self->parent->short_name . "/". $self->name;
    }

  sub mv {
    my $self=shift;
    my ($to, %keyargs) = @_;
    my $author = $keyargs{'author'};

    debug { "mv ".$self->short_name." -> ".$to->short_name };

    my $project_ct;

    if (!$self->exists) {
          warn "# Source patch doesn't exist: ".$self->path."/patch.xodp\n";
          exit 2;
          }
    if ($to->exists || -e($to->path) ) {
          warn "# Destination patch/dir already exists, don't know how to replace and update names in that case: ".$to->path."\n";
          exit 2;
          }

    # my $full_patch_path; # TO patch to .xodp
    #my $newlibpath = shift @ARGV; # FROM just libpath
    #my ($patch_decl, $has_native, $inputs, $outputs) = process_patchfile( $full_patch_path );
    #mv_patch($newlibpath, $full_patch_path, $patch_decl, $has_native);

    # in this project/lib
    my $patch_ct = $self->parent->rename_nodes( $self, $to ); # Fail if $from has other @/
    if ($patch_ct) {
      warn "# edited ".$self->parent->short_name." patches $patch_ct\n";
      $project_ct += 1 
      }

    if ($self->parent->is_library) {
      # from a library means editing all other projects & libs

      for my $proj ( @{XODProject->projects} ) {
        $patch_ct = $proj->rename_nodes( $self, $to );
        if ($patch_ct) {
          warn "# edited ".$proj->short_name." patches $patch_ct\n";
          $project_ct += 1 
          }
        }

      if (! $author) {
        warning "Can't edit libraries without an author.";
        }
      else {
        for my $lib ( @{XODProject->libraries($author)} ) {
          next if $lib->short_name eq $self->short_name;

          $patch_ct = $lib->rename_nodes( $self, $to );
          if ($patch_ct) {
            warn "# edited ".$lib->short_name." patches $patch_ct\n";
            $project_ct += 1 
            }
          }
        }
      }
    warn "# edited projects/libs: $project_ct\n" if $project_ct;
    }

  sub xodp_path { shift->path . "/patch.xodp"; }

  sub xodp {
    my $self=shift;

    return $self->_xodp if $self->_xodp;

    my $xodp_path = $self->xodp_path;
    #debug {"read json patch $xodp_path" };
    confess "no such ".$xodp_path if ! -e $xodp_path;
    if (-d $xodp_path) {
      warning "Was a directory: ".$xodp_path;
      $self->_xodp( undef );
      return undef;
      }

    if (!$self->exists) {
      $self->_xodp( {} ); # for new
      return $self->_xodp
      }

    local @ARGV = $xodp_path;
    my $rez = eval { $self->_xodp( decode_json(join("",<>)) ); };
    if ($@) {
      warn "In ".$self->xodp_path." : ";
      warn $@;
      exit 1;
      }
    warning "No json in $xodp_path" if !$rez;
    #debug {"json ".$rez};
    $rez;
    }

  sub nodes {
    my $self=shift;
    return undef if ! $self->xodp;
    $self->xodp->{'nodes'} || ( $self->xodp->{'nodes'} = [] );
    }

  sub save {
    my $self=shift;
    if (!$self->_xodp) {
      die "Can't save, never read the xodp ".$self->short_name;
      }

    my $str = to_json($self->_xodp, {utf8=>1, pretty => 1, canonical=>1}); # can't: , indent_length =>2});
    $str =~ s/^((:?   )+)/ '  ' x (length($1)\/3) /egm; # indent 2
    $str =~ s/("[^"]+") :/$1:/gm;

    my $is_new = !$self->exists;

    if (! $switches->{'n'}) {
      my $fh = IO::File->new( $self->xodp_path, 'w') || die($!);
      print $fh $str;
      $fh->close || die($!);
      }
    warn "# ".($switches->{'n'} ? "(didn't) " : '').($is_new ? 'saved' : 'updated' )." ".$self->short_name."/patch.xodp\n";
    }

# end XODPatch

package XODProject;
  # Anything that has project.xod: project/library
  # Use .factory(path) to make the right subclass if thing already exists
  use Class::MethodMaker 
    [ 
    new => [ qw( -init new )],
    scalar => [ 
      'path', # canonical path
      ],
    ];

  use File::Basename qw(basename dirname);
  use Carp;


  our $workspace = Cwd::abs_path("/home/".$ENV{'USER'}.'/xod');

  sub debug(&){ goto &main::debug; }
  sub warning { goto &main::warning; }
  sub FIXME{ goto &main::FIXME; }

  sub type { 'project' }

  sub factory {
    # given a path, return the right kind of object: project|lib
    # Do not try to classify to patch

    my $self=shift; # class|object
    my ($path) = @_;
    debug {"# Factory classify: '$path'"};

    if (!-e $path) {
      # guess from pattern

      my $partct = split('/', $path);
      debug {"  # non-extant, parts $partct"};

      if ($partct == 1) {
        # project
        debug { "Assume new xodproject: 1 part path" };
        XODProject->new( "$workspace/$path" );
        }
      elsif ($partct == 2) {
        # author/lib
        debug { "Assume a library: 2 part path" };
        XODLibrary->new( "$workspace/__lib__/$path" );
        }
      elsif ($partct == 3 && $path !~ /(^|\/)lib\// ) {
        # don't classify to patches
        die "Can't classify non-extant path, expected project or author/lib: $path";
        }
      elsif ( $path =~ /(^|\/)lib\// || index(Cwd::abs_path($path), "$workspace/__lib__") == 0 ) {
        # In lib, could be library, or a patch
        $path =~ /\b(lib|__lib__)\//;
        my $libname = $';
        debug { "Assume in lib|__lib__: classify $'" };
        
        $partct = split('/', $libname);

        if ($partct == 2) {
          # author/lib
          debug { "Assume new xodlibrary in lib/|__lib__ /a/b" };
          XODLibrary->new( $path );
          }
        else {
          die "For non-extant path, expected author/name parts after lib|__lib__: $path" ;
          }
        }
      elsif ( index(Cwd::abs_path($path), $workspace) == 0 ) {
        # not lib, so project something
        my $projname = substr( length($workspace."/"), Cwd::abs_path( $path ));
        debug { "Assume new xodproject: in ~/xod/$projname" };
        
        $partct = split('/', $projname);

        if ($partct == 1) {
          # project
          debug { "Assume new project in workspace/a" };
          XODProject->new( "$workspace/$path" );
          }
        else {
          die "Can't classify the non-extant path in workspace, expected project: $path";
          }
        }
      else {
        die "Can't classify the non-extant path, should look like project, author/lib, ~/xod/project, or something in lib|__lib__: $path";
        }
      }
    }

  sub init {
    my $self=shift;
    my ($path, @keyargs) = @_;
    # keyargs:
    my %keyargs = @keyargs;
    $self->path( Cwd::abs_path($path) );
    die "Couldn't figure abs_path('$path'), didn't give prefix to workspace?" if !$self->path;
    }

  sub patch {
    # patch object in project
    my $self=shift;
    my ($patchname) = @_;
    #debug {"making patch"};
    XODPatch->new($self, $patchname );
    }

  sub is_project {
      my $self=shift;
      $self->type eq 'project';
      }

  sub is_library {
      my $self=shift;
      $self->type eq 'library';
      }

  sub exists {
    # does the project/lib actually exist
    my $self=shift;
    -e $self->path . "/project.xod";
    }

  sub path_tail {
    # 1 for project, 2 for lib
    my $self=shift;
    my ($ct, $apath) = @_;
    my @parts = basename($apath);

    my $dir = dirname($apath);
    for ((1..($ct-1))) {
      unshift @parts, basename($dir);
      $dir = dirname($dir);
      }

    join("/", @parts);
    }

  sub short_name {
    my $self=shift;
    basename($self->path);
    }

  sub rename_nodes {
    # just rename references in ourselves

    my $self=shift;
    my ($from, $to) = @_;

    debug { "Rename in ".($self->type)." ".$self->short_name." ".$from->short_name." -> ".$to->short_name };

    my $new_node_name = $to->short_name;
    my $old_node_name = $from->short_name;

    # if same proj/library
    if ($self->short_name eq $to->parent->short_name) {
      debug { "# same to so @" };
      $new_node_name = '@/' . $to->name;
      }
    # if same proj/library
    if ($self->short_name eq $from->parent->short_name) {
      debug { "# same from so @" };
      $old_node_name = '@/' . $from->name;
      }

    debug { "# rename in ".($self->type)." ".$self->short_name.", ".$old_node_name." -> $new_node_name" };

    my $patch_ct;

    for my $apatch ( @{ $self->patches() } ) {
      #debug { "Consider ".$apatch->short_name };

      my $nodes = $apatch->nodes || [];
      if (! @$nodes) {
        warning "No nodes in ".$apatch->short_name;
        next;
        }

      my @nodes_to_edit = grep { 
        # we edit and grep at same time
        if ( $_->{'type'} eq $old_node_name ) {
          $_->{'type'} = $new_node_name;
          }
        else {
          undef;
          }
        } @{$apatch->nodes};
      #debug { "  nodes w/ $old_node_name ".@nodes_to_edit };
      next if !@nodes_to_edit;

      $patch_ct += 1;
      debug { "  edited ".$apatch->short_name." xodp type $old_node_name : ".@nodes_to_edit };
        
      $apatch->save;
      }
    debug {"  edited patches $patch_ct"} if $patch_ct;
    $patch_ct;
    }

  sub patches {
    # in this project
    my $self=shift;

    my @patches;
    for my $projpath (glob($self->path . '/*')) {
      next if !-d $projpath;

      push @patches, $self->patch( basename($projpath) );
      warning "patch from globbing, but no patch.xodp exists: ".$patches[-1]->path  if !$patches[-1]->exists;
      pop @patches if !$patches[-1]->exists;
      }
    return \@patches;
    }

  sub projects {
    # just list 'em
    my $self=shift; # class|object

    my @projects;
    for my $projpath (glob("$workspace/*")) {
      next if !-d $projpath;
      next if $projpath =~ /\/__lib__\//;

      push @projects, XODProject->new( $projpath );
      }
    return \@projects;
    }

  sub libraries {
    # just list 'em: requires 'author'
    my $self=shift;
    my ($author) = @_;

    my @libs;
    for my $libpath (glob("$workspace/__lib__/$author/*")) {
      next if !-d $libpath;
      push @libs, XODLibrary->new( $libpath );
      }
    return \@libs;
    }

#end XODPatch

package XODLibrary;
  # A thing that has a project.xod, but has other library semantics:
  # 3 level name
  #...

  use Carp;

  use base('XODProject');
  sub debug(&) { goto &main::debug; }
  sub warning { goto &main::warning; }
  sub FIXME { goto &main::FIXME; }

  sub init {
    my $self=shift;
    my ($path) = @_;
    
    my $partct = split('/', $path);
    if ($partct == 2) {
      debug {"Assume in __lib__ 2part"};
      $self->SUPER::init( "$workspace/__lib__/$path" );
      }
    else {
      $self->SUPER::init($path);
      }
    }

  sub type {'library'}

  sub short_name {
    my $self=shift;
    $self->path_tail(2, $self->path);
    }


# end XODLibrary

package main;

sub find_project {
    my ($want) = @_;
    debug { "Look for project in $workspace for $want/project.xod..."; };
    # FIXME strip project.xod, strip workspace, ... or converse rather
    # If it's a patch, strip it back to project
    # allow relative to here (./)
    if (-e "$workspace/$want/project.xod") {
        debug { "  found project '$workspace'/'$want'" };
        "$workspace/$want";
        }
    else {
        debug { "  not found project '$want'" };
        undef;
        }
    }

sub search_project {
    my ($want) = @_;
    debug { "Search in $workspace for ~$want/project.xod..."; };
    my $i=0;
    foreach (bsd_glob( "$workspace/*$want*/project.xod", GLOB_NOCASE )) {
        if (!$i) {
            say "## Maybe you meant projects:";
            $i=1;
            }
        my $project = dirname($_);
        $project =~ s/^\Q$workspace\E\///;
        say "\t$project";
        }
    warning "No projects found\n" if $i==0;
    }

sub path_to_patch {
  my ($path, $relative_path) = @_;

  my $partct = split('/', $path);
  if ($partct==1 && $relative_path) {
    $relative_path->patch($path);
    }

  else {
    XODPatch->new($path, author=>$switches->{'author'});
    }
  }

sub move_or_rename {
    # Move/rename the patch
    # path/patch path # moves to other project|lib, same name
    # path/patch [path/]patch # renames to [other] project|lib
    # path is [absolutepath/]projectname, or [absolutepath/lib|__lib_/]author/libname
    # Changes to a lib require possibly fixup of all other projects
    # And "our" libraries
    # And so require '-a author' for the lib prefix of things that might need fixing
    # It's a lib if __lib__/... or 1/2/3 or lib/...


    if (@ARGV != 2) {
      warn "Expected a from & to\n";
      exit 1;
      }

    my $from = XODProject->factory( dirname($ARGV[0]) )->patch( basename($ARGV[0]) );
    if ( $from->parent->is_library && !$switches->{'author'} ) {
      warn "Need a '-a \$author' to edit libraries";
      exit 2
      }

    # patch -> rel
    # proj/patch
    # auth/lib/patch

    my $to;

    if ( $ARGV[1] !~ /\// ) {
      $to = $from->parent->patch( $ARGV[1] ); # relative
      }
    else {
      $to = XODPatch->new( $ARGV[1] );  
      }

    $from->mv( $to, author => $switches->{'author'} );

    }

sub xodp {
  my ($patch_path) = @_;
  local @ARGV = $patch_path;
  confess "no such $patch_path" if ! -e $patch_path;
  decode_json(join("",<>));
  }

sub process_patchfile {
    my ($full_patch_path) = @_;

    my $patch_decl = xodp($full_patch_path);
    # warn "json: ".Dumper($patch_decl)." "; use Data::Dumper;
    debug { "Read $full_patch_path: ". join(" ", sort keys %$patch_decl) . ": " };
    debug { map { chomp; "\t\"$_\"" } split "\n", $patch_decl->{'description'} };

    my $has_native = 0;
    my $has_non_xod_patch = 0;
    my @inputs;
    my @outputs;
    debug { "Nodes..." };
    foreach ( @{ $patch_decl->{'nodes'} ||[]} ) {
        $has_native +=1 if $_->{'type'} eq 'xod/patch-nodes/not-implemented-in-xod';
        $has_non_xod_patch +=1 if $_->{'type'} !~ /^xod\/patch-nodes/;
        if ($_->{'type'} =~ /^xod\/patch-nodes\/input-(.*)/) {
            my $type = $1;
            push @inputs, { type => $type, name => $_->{'label'} };
            }
        if ($_->{'type'} =~ /^xod\/patch-nodes\/output-(.*)/) {
            my $type = $1;
            push @outputs, { type => $type, name => $_->{'label'} };
            }
        }
    my $has_links = @{ ($patch_decl->{'links'} || []) };

    debug { "  has native $has_native" };
    debug { "  has non i/o $has_non_xod_patch" };
    debug { "  has links ".$has_links };
    debug { "  has inputs ".@inputs.": ".join(" ", map { $_->{'name'} } @inputs) };
    debug { "  has outputs ".@outputs.": ".join(" ", map { $_->{'name'} } @outputs) };
    # warn Dumper(\@inputs); use Data::Dumper;

    my @fails;

    warning "Has no inputs (xod/patch-nodes/input-*), which doesn't make sense" if (!@inputs);
    warning "Has no outputs xod\/patch-nodes/output-*, which might be ok" if !@outputs;

    if ($has_native && $has_links) {
        push @fails, "Has native node (xod/patch-nodes/not-implemented-in-xod) but also links, which doesn't make sense (in project's patch $full_patch_path)";
        }
    if ($has_native > 1) {
        push @fails, "Has $has_native > 1 native nodes (xod/patch-nodes/not-implemented-in-xod), which doesn't make sense (in project's patch $full_patch_path)";
        }
    if (!$has_native && !$has_links) {
        push @fails, "Has no native node, and no links, which doesn't make sense (in project's patch $full_patch_path)";
        }
    if ($has_native && $has_non_xod_patch) {
        push @fails, "Has native and non 'xod/patch-nodes/*' nodes, which doesn't make sense (in project's patch $full_patch_path)";
        }
    if ( !$has_native && -e "$full_patch_path/patch.cpp" ) {
        push @fails, "Has no native but has patch.cpp, which doesn't make sense (in project's patch $full_patch_path)";
        }
    warning "Has native but no patch.cpp" if ( $has_native && !-e "$full_patch_path/patch.cpp" );

    if (@fails) {
        warn "FAIL\n".join("\n", @fails)."\n" ;
        exit(1);
        }
    return ($patch_decl, $has_native, \@inputs, \@outputs);
    }

sub to_json_string {
  my ($xodp) = @_;
  # canonical, etc. "standard xodp"
  my $str = to_json($xodp, {utf8=>1, pretty => 1, canonical=>1}); # can't: , indent_length =>2});
  $str =~ s/^((:?   )+)/ '  ' x (length($1)\/3) /egm;
  $str;
  }

sub mv_patch {
    # mv the patch dir to a new location
    my ($newlibpath, $full_patch_path, $patch_decl, $has_native) = @_;

    my $patchfile = "$newlibpath/".basename($full_patch_path);
    debug { "  will create ".basename($patchfile) };
    
    warning "Needs Description" if !$patch_decl->{'description'};

    if (! $switches->{'n'}) {
      system( 'mv', dirname($full_patch_path), dirname($patchfile) );
      }
    warn "#" .($switches->{'n'} ? "(didn't)" : '') . " move to $patchfile\n";
    }

sub main {
    given ($ARGV[0]) {
        when (/^-/) {
            # ok
            }
        default {
            # ok
            }
        }
    
   $switches=awgrover::Getopt::GetOptions
                (
                '' => <<'EOS',
Move a "patch" in a project to a lib (fixes up old references in project).
Does not know how to cope with custom-types yet.
(general would be path/patch [path][/patch] for mv/rename project/lib)
--- [options] project patch libpath # project/patch -> lib
      project # name in ~/xod, or full path
      patch # dir in project, or dir/something.xodp
      libpath # name in ~/xod/__lib__, destination
--- [options] patch-path libpath # patch -> lib, deduces project-portion
      patch-path # full path to .../$project/$path[/patch.xodp]
      libpath # name in ~/xod/__lib__, destination

--- [options] -a author libpath/patch newpatchname # rename, short form of:
--- [options] -a author libpath/patch newlib/newpatchname # mv to another library, fixes all projects, fixes all -a libs
EOS
                'author|a=s' => 'author prefix part for libs',
                'help|h|H'=>'this',
                'n' => "don't make changes",
                );

    move_or_rename;
    }

main();
